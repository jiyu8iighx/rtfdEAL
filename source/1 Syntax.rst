================
形式文法
================

--------------------
符号的形式模型
--------------------
符号的形式模型是前缀树（trie）：

.. image:: assets/trie.png
	:alt: 前缀树的一个可视化了的示例

借助括号就可以用文字表示它（我习惯使用方括号）：

.. code::

	Plus[a, Power[b, 2], Power[c, 3], d]

在上式中 ``Plus`` 、 ``Power`` 总是位于括号的前面，我约定称：「 ``Power`` 是 ``Power[b,2]`` 这个 **符号式** 的 **头部**」。在图片中它们则处于树的根部，这个说法很形象但我将不采用。
``a`` 、 ``Power[b,2]`` 等位于括号内部，我约定称： ``b`` 和 ``2`` 是符号式 ``Power[b,2]`` 的 **子式** 。按照这个说法， ``a`` ``Power[b, 2]`` ``Power[c, 3]`` ``d`` 则是整个式子的子式 。在树的比喻中，子式的概念对应于树的分枝。

尽管 ``a`` ``2`` 这样的符号没有任何分支，但我约定：仍称它是一个符号式，只不过它是一个不可进一步分解的 **原子式** 。不是原子式的式子称为 **复合式** 。在树的比喻中，复合式中包含的各个原子式是这个复合式的叶子。

上面的字符序列并不是一个EAL句子，而是只用于表示句子背后的形式模型，能方便讨论。
画图是比较费力的，以后我都将使用这种“平坦”的方法。
另有一套更合适的序列化方法来生成真正的EAL句子，那将比较接近于自然语言的样子，而且比较适合人类识别、书写、发音。

--------------------
符号式的语义解释
--------------------
EAL词汇表中，会写有类似下面的 **符号定义** ：

.. code::

	Friend : Friend[x, y] = "x和y是朋友"

如果再引入两个新的定义：

.. code::

	I : I = "我"
	He : He = "他"

我们就可以用 ``Friend[I, He]`` 来表达「我和他是朋友」了。

第一条定义中，我约定： ``Friend`` 称为 **定义绑定的对象符号** ，``Friend[x, y]`` 称为 **定义对象** ，称 **"x和y是朋友"** 为 **语义** 。
在这条定义中，出现了 ``x`` ``y`` 这种无实际语义的符号，这类似编程语言中常说的「函数的形式参数」，这里我约定称它们是 **语义模板的插槽** 。

可以看到，后两条定义中没有这样的插槽，定义的对象是符号本身，这两个定义就没有什么「模板」的意味。

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
嵌套的符号式的解释
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
"""""""""""""""""""""
返回所进行的陈述
"""""""""""""""""""""
定义

.. code::

	Know : Know[x, y] = "x知道y"

两层的嵌套式 ``Know[I, Know[I, He]]`` 的语义是「我知道「我知道他」这事」。

可以看出，定义中的插槽 ``y`` 可以被另一个符号式 ``Know[I, He]`` 填充，意为「「我知道他」这事」。

在解释外层的 ``Know`` 时，内层的子式将一个式子及其语义 **返回** 给了外层。
在上例中，内层式子的 **返回式** 是 ``Know[I, He]`` 整体， **返回语义** 是「「我知道他」这事」。

``Know[I, He]`` 之所以解释为「「我知道他」这事」，是因为这是一项通用的约定，一个式子作为返回式时的语义将是一个陈述。
形式上说，这相当于有这样一个全局的语义定义：

.. code::

	f[g[a,b]] = f["g[a,b]这事"]

"""""""""""""""""""""
返回子式
"""""""""""""""""""""

一个式子不但可以返回它所表达的陈述，还可以 *在完成陈述后* 返回这个陈述中所涉及的对象：

两层的嵌套式 ``Know[I, Know1[He, She]]`` 的语义是「我知道他，他知道她」。
其中， ``Know1`` 末尾的标记 ``1`` 表明返回值是 ``Know1[He, She]`` 的第一个子式 ``He`` ，其语义是「他」。

EAL还允许你在符号后添加标记 ``2`` ，``Know2[He, She]`` 返回它的第二个子式 ``She``。

语义模板通常只有一两个重要的插槽，所以EAL只支持返回前两个子式。算上无标记的情况，一共有三种返回式。

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
缺失插槽的语义模板的解释
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
"""""""""""""""""""""""""
返回式处于缺失插槽的情况
"""""""""""""""""""""""""

实际的EAL词汇表中没有「我」、「他」这样的“名词性”的词，EAL词汇表中的 *几乎* 所有定义都采用「语义模板」，而不是以符号这个原子式为定义对象。
如果任何符号本身没有语义，那么在有语义的式子中，所有符号都只能位于式子的头部。
你可能会好奇：一个没有“名词”的语言要如何使用？ ``Friend[x, y]`` 的插槽 ``x`` ``y`` 如果不能由 ``Me`` 这样的符号填充，又要由什么来填充呢？

实际上，EAL中只有这样的定义：

.. code::

	IsMe : IsMe[x] = "x是我"

要表达「我和他是朋友」，需用此式： ``Friend[IsMe1[], IsHim1[]]`` 。

可以注意到，语义模板中有一个插槽，但在式中却没有填充这个插槽。不但如此，还添加了标记 ``1`` 来要求返回这个未提供的子式。

对于 ``IsMe[]`` 这种缺失插槽的语义模板，解释过程中会创建一个 **变量** 。如，解释 ``IsMe1[]`` 的过程是:

#. 创建一个变量，此处记作 ``a``
#. 陈述「 ``a`` 是我」
#. 返回 ``a`` 给外层符号式

解释 ``Friend[IsMe1[], IsHim1[]]`` 时，一共进行了「 ``x`` 是我」、「 ``y`` 是他」、「 ``x`` 和 ``y`` 是朋友」三个陈述。

EAL不直接为事物起名字，但有摹状词。当摹状词的描摹对象被省略，我们就能利用返回机制将对象返回来代表事物。

"""""""""""""""""""""""""""
返回式不处于缺失插槽的情况
"""""""""""""""""""""""""""
要表示「我理解（什么是）朋友关系」，需用此式： ``Know[IsMe1[], Friend[]]`` 。

``Friend`` 没有任何子式，这时返回式是 **抽象** 的，表达「朋友关系」。

.. note::
	在一阶逻辑模型中，谓词本身是不可量化的，也就不存在更抽象的高阶谓词。
	这时，返回式表达的也不是语义模板本身，而是两个插槽都被全称量化后的朋友关系命题，「我理解朋友关系」的含义应是「我理解所有的朋友关系命题」。
	EAL不试图声称自己是一阶逻辑模型，也就是说形式上允许对谓词的量化，所以你可以将上式的返回语义认为是抽象的「朋友关系」本身。

//巨坑待填：模糊状态与类

"""""""""""""""""""""
不唯一的指称对象
"""""""""""""""""""""
``Friend2[IsMe1[],]`` 的返回语义是「我的朋友」。
但能令 ``Friend[Me, x]`` 成立的 ``x`` 可以有多个，这个返回语义的指称对象究竟是我的哪一个朋友？

EAL这样约定：使用标记 ``1`` 和 ``2`` 时，就已默认返回值是唯一的，也就是说进行了唯一存在量化。
从而 ``Friend2[IsMe1[],]`` 的确切的返回语义是「我那唯一的朋友」。

若要表达「我的每个朋友」，需额外添加全称量化的标记 ``A`` 。也就是说「我的每个朋友」要由 ``Friend2A[IsMe1[],]`` 来表示。

特称量化标记则是 ``E`` 。「我有个朋友死了」记作 ``IsDead[Friend2E[IsMe1[],]]`` 

.. note::
	有的语义模板的插槽的唯一性是恒真的。如「 ``IsFather: IsFather[a, b] = a是b的父亲`` 」，对于给定的 ``b`` 只有一个 ``a`` 令命题成立。
	尽管对 ``IsFather1[,IsMe1[]]`` 的返回语义的唯一量化并不是逻辑重言式，但这个量化仍是“多余”的。
	这就是为什么我将「唯一量化」作为默认的行为，而要求全称量化和特称量化的情况添加额外的标记。

//巨坑待填：模糊状态与类

^^^^^^^^^^^^^^^^^^^^
选项
^^^^^^^^^^^^^^^^^^^^
待写……

----------------------
符号树的正式序列化方案
----------------------

^^^^^^^^^^^^^^^^^^^^
文法
^^^^^^^^^^^^^^^^^^^^
对前缀树进行序列化的方法先前已经介绍了一种，但它包含无语义的字符 ``[,]`` ，且一般人较难对它进行高效的理解（尤其是在通过听的方式来接收语句时）。

现在介绍如何将前文的这种符号式转化为正式的EAL语句。

"""""""""""""""""""""
运算符
"""""""""""""""""""""
EAL规定，符号式 ``Friend[a, b]`` 应序列化为

.. code::

	a FRIENDti b

其中，空格是 **分词符** ，被它分出来的字符段则称为 **词** 。 ``FRIENDti`` 是一个 **中缀运算符** ，它将 **结合** 它前面和后面的词所构成的符号式。

只有一个子式的符号式 ``IsMe[a]`` 则序列化为

.. code::

	a ISMEta

也就是说， ``ISMEta`` 是一个 **后缀运算符** 。

由于语义模板的插槽可以省略，所以往往也会有没有任何子式的符号式，如 ``IsMe1[]`` 。
它序列化为 ``ISMEko`` ，它只包含一个词，这个词是一个 **零元运算符** ，不需要结合附近的词。

可以注意到，运算符比相应的符号名在末尾多了两个字符，这两个字符分别标记着「返回式的类型」和「结合方式」。具体情况要分类讨论，参见下面的表：

.. csv-table::
	:header: 第一后缀字符,返回式的类型

	t,返回整个符号式，相当于没有添加前文所说的返回类型标记
	k,返回第一子式，相当于返回类型标记 ``1``
	s,返回第二子式，相当于返回类型标记 ``2``

.. csv-table::
	:header: 第二后缀字符,运算符的结合方式

	a,结合运算符左端的一个符号式，将其作为第一子式。也就是说运算符将是后缀运算符。
	i,结合运算符左端的一个符号式，将其作为第一子式；并结合运算符右端的一个符号式，将其作为第二子式。也就是说运算符将是中缀运算符。
	u,结合运算符左端的一个符号式，将其作为第二子式。也就是说与 ``a`` 的情况有相反的插槽填充行为。
	e,结合运算符左端的一个符号式，将其作为第二子式；并结合运算符右端的一个符号式，将其作为第一子式。也就是说与 ``i`` 的情况有相反的插槽填充行为。
	o,不进行任何结合。也就是说运算符将是零元运算符。

使用这一套标记法则的话，如果定义 ``a Gti b`` 表示「 ``a`` 大于 ``b`` 」，那么表示「 ``a`` 小于 ``b`` 」的EAL语句可以有两种：

#. ``b Gti a``
#. ``a Gte b``

由于这两类标记指定了运算符的输入（Input）输出（Output）间的关系，故称它们构成了 **运算符IO标记** 。

"""""""""""""""""""""
多层符号式的序列化
"""""""""""""""""""""
多层符号式，比如 ``G[c, G1[a, b]]`` （意为「 ``a`` 大于 ``b`` 且 ``a`` 小于 ``c`` 」）转化为如下EAL语句：

.. code::

	a Gki b Gte c

注意到句中的 ``b`` 左右两端都有运算符，它有两种结合的可能：

#. ``b`` 先与左边的 ``a Gki`` 结合为 ``G1[a, b]`` ，陈述「 ``a`` 大于 ``b``」并返回 ``a`` ，返回式再与右边的 ``Gte c`` 结合为 ``G[c, a]`` ，陈述「 ``a`` 小于 ``c`` 」
#. ``b`` 先与右边的 ``Gte c`` 结合为 ``G[c, b]``  ，返回 ``G[c, b]`` ，返回式再与左边的 ``a Gki`` 结合为 ``G[a, G[c, b]]`` ，陈述「 ``a`` 小于「 ``b`` 小于 ``c`` 这事」」（理解不通）

语言必须保证解释方式是唯一的，EAL也就必须规定上面两种解释结果中只有一种正确。当有两个运算符“争抢”同一个符号式时，我们按照以下原则确定争抢的赢家：

#. 比较两个运算符的 **优先级** 。优先级是一个数，将和语义定义一通写在词汇表中，优先级较大的运算符将成功抢到这个符号式。绝大多数EAL语义模板都将具有相同的优先级。对于上面的例子，运算符都是由同一语义模板 ``G`` 派生的，必然具有相同的优先级，此时单凭优先级不能判断争抢的结果，要看下一条判据。
#. 一元运算符总是优先于二元运算符。对于上面的例子，争抢的双方都是二元运算符，此时单凭此判据不能判断争抢的结果，要看下一条判据。
#. 如果对于一类运算符 ``f`` ， ``a f b f c`` 总是构造为 ``f[f[a, b], c]`` ，也就是说符号式优先和左端的运算符结合，那么就称这类运算符是 **左结合性的** 。 **右结合性** 也可以类似地定义。具有相同优先级的运算符将具有相同的结合性，所以结合性总是能决出最终的赢家。EAL中的绝大多数运算符都将是左结合性的（方便了左至右的阅读顺序习惯），上例中的 ``G`` 也将不会例外。

如果有时需要刻意违反这种默认的结合规则，可以添加括号：

.. code::

	c Gti [ b Gke a ]

此语句也意为「 ``a`` 大于 ``b`` 且 ``a`` 小于 ``c`` 」。

括号是一个语法词，可以用拉丁字母表示，也可发音。EAL约定，句首的左括号、句末的右括号可以省略，从而此语句可以简化为

.. code::

	c Gti [ b Gke a

"""""""""""""""""""""
选项的指定
"""""""""""""""""""""
待写……

"""""""""""""""""""""
词汇表内容的分类
"""""""""""""""""""""

- 非运算符
	- 运算符源：通过后缀标记 ``t,k,s; a,i,u,e,o`` 派生为运算符后才能成为句子中的词
		- 普通模板：数量最多的词。
			- 短普通：非常常用的词。它们的返回值标记、结合方式标记在特定情况下可以省略。
			- 长普通：没有特别的语法规则。
		- 元模板：其返回值是语义模板，也就是说它们进行词的派生。返回值标记、结合方式标记在特定情况下可以省略；可以无需空格地作为后缀直接添加到其它词的尾部；具有特别的优先级与结合性。
			- 有序模板：由于派生的语义与模板的填充顺序有关，``i/e`` ``a/u`` 标记的不同选择将有不同的结果。故插槽需由一个普通模板派生而来的运算符填充。
			- 无序模板：插槽直接由一个普通模板填充。
	- 特殊：数、历法等特殊系统的组分，具有特殊的语法规则。
- 运算符：无需派生，直接作为运算符加入到句中。都是极为特殊的词，如量词。可以具有特殊的

可以看出，前文介绍的语法规则还仅限于「普通模板」，还有更多的特殊语法规则未介绍。那些规则不是必要的，仅仅为降低表达的成本而设计的，将会在相应概念体系的进行时详细介绍。

^^^^^^^^^^^^^^^^^^^^
发音
^^^^^^^^^^^^^^^^^^^^
暂时不详细设计。

--------------------
附表
--------------------

^^^^^^^^^^^^^^^^^^^^
术语对照表
^^^^^^^^^^^^^^^^^^^^
本章中的术语有时是使用了逻辑等领域的既定术语，有时则是自创的。
自创的术语的含义也会接近于某些领域的某些已有术语，为方便读者理解，现将相似的术语列在下面：

.. csv-table::
	:header: 本文档所用的术语,逻辑学术语,语言学术语,程序语言学术语,日常生活用语
	
	符号式,项,论元,符号表达式（LISP）,树
	子式,,子句（从句是子句的一种）,子表达式,枝
	复合式,表达式,,非原子的表达式,没有枝的树
	原子式,,语素,原子,叶
	符号,符号,词,变量名,
	（符号的）定义,解释（的方法）,,模式匹配的规则,
	定义绑定对象,,,,
	定义对象,,,模式匹配的键,
	定义语义,,,模式匹配的值,
	语义模板,谓词,,Lambda函数,
	语义模板的插槽,,,函数的形式参数,
	返回式,,,返回值,
	返回语义,返回式的解释结果,,,
	变量,变量,,,

^^^^^^^^^^^^^^^^^^^^
IO标记应用示例
^^^^^^^^^^^^^^^^^^^^

.. csv-table::
	:header: IO标记,所替代的的自然语言结构,示例语句,返回式的语义,翻译
	
	ko,名词,是我ko,是我者,我
	ka,形容词,是我ko 活着ka,是我者活着,活着的我
	ki,带变元的形容词/连词,3 大于ki 2 大于ti 1,大于2的3大于1,3大于2并大于1
	si,带变元的形容词/连词,3 大于ki 2 大于ti 1,小于3的2大于1,2小于3并大于1
	ku,属格,是我ko 是父亲ku,唯一的「是我父亲者」,我的父亲
	sa,属格,略（与sa相似，仅仅是“模板填充顺序”相反）,,
	ta,动词（返回式相当于从句）,是我ka 知道ti 是我ka 活着ta,是我者知道是我者活着,我知道我活着
	ti,动词,是我ka 知道ti 是我ka 活着ta,是我者知道是我者活着,我知道我活着
	te,被动动词,是我ka 活着ta 知道te 是我ka,是我者活着被是我者知道,我知道我活着
	to,概念名词,是父亲to,父子关系,父子关系

	