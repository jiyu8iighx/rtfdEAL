================
介绍
================

本文的符号约定：

* 术语首次出现时将被加粗，一般来说此时它正在被定义。

-------------
设计意图
-------------

寻找语义的共通模式，承载哲学概念分析的结果，通过降低文法支持用户用少量基本概念表达复杂概念。

此语言应当：

* 实现理念

	- 能够表达所有需要表达的对象
	- 鼓励用户更多地使用原子概念（不可分解的概念）的组合去表达各种对象，而非为每一种不同的事物都起新的名字。
	- 具有明确的语义，且语义的解释应 **能够** 不依赖于语境。（但也可以使其依赖于语境，提高便利性，将解释的任务交给语用学的层面）
* 可一维书写、朗读
* 取得人工语言相对自然语言的各种（可获得的）优势，比如：
  
	- 消灭同音字
	- 消灭同义词
	- 语法遵循统一的规律，无例外情况，利于学习。
	- 语言定义明确。进而需要改动时，改动的具体事项也会很明确。
* 具有好的可拓展性：
  
	- 便于添加新词
	- 便于人机交互，进而支持键盘输入、语法检查、语义分析、语音输入等

^^^^^^^^^^^^^^^^^^^^
我所要设计的是什么
^^^^^^^^^^^^^^^^^^^^

* 一门实用语言、文法上注重便捷性的语言
* 一门提倡精确表达的语言，一门承载概念分析成果的语言
* 一门对使用者的思维有反作用的语言
* 一门可发展的语言，一门实验性语言
* 一套文法和一个（大体上是树状的）概念体系

^^^^^^^^^^^^^^^^^^^^
我所要设计的不是什么
^^^^^^^^^^^^^^^^^^^^

* 对文学等艺术形式提供刻意支持的语言
* 一门提倡隐喻、语境理解的语言，一门适合作为精神分析的分析对象的语言
* 一门很接近自然语言、从而用户可以类比着学习的语言
* 不需要进一步发展、改良的“终极”语言
* 具体的文字、语音、词汇

^^^^^^^^^^^^^^^^^^^^
关于哲学立场
^^^^^^^^^^^^^^^^^^^^

此语言具有强的工程性质。它不试图消解语言哲学以外的哲学，只是为语言哲学提供工具。它也不局限于特定的概念分解路线（比如物理主义和现象主义），而是可能采用所有的路线来提高表达的便利性。

--------------------
符号的形式模型
--------------------
符号的形式模型是前缀树（trie）。

.. image:: assets/trie.png

借助括号就可以用文字表示它（我习惯使用方括号）：

``Plus[a, Power[b, 2], Power[c, 3], d]``

在上式中 ``Plus`` 、 ``Power`` 总是位于括号的前面，我约定称：「 ``Power`` 是 ``Power[b,2]`` 这个 **符号式** 的 **头部**」。在图片中它们则处于树的根部，这个说法很形象但我将不采用。
``a`` 、 ``Power[b,2]`` 等位于括号内部，我约定称： ``b``和 ``2`` 是符号表达式 ``Power[b,2]`` 的 **子式** 。按照这个说法， ``a`` ``Power[b, 2]`` ``Power[c, 3]`` ``d`` 则是整个式子的子式 。在树的比喻中，子式的概念对应于树的分枝。

尽管 ``a`` ``2`` 这样的符号没有任何分支，但我约定：仍称它是一个符号式，只不过它是一个不可进一步分解的 **原子式** 。不是原子式的式子称为 **复合式** 。在树的比喻中，复合式中包含的各个原子式是这个复合式的叶子。

上面的字符序列并不是一个EAL句子，而是只用于表示句子背后的形式模型，能方便讨论。画图是比较费力的，以后我都将使用这种「平坦」的方法。
另有一套更合适的序列化方法来生成真正的EAL句子，那将比较接近于自然语言的样子，而且比较适合人类识别、书写、发音。

--------------------
符号式的语义解释
--------------------
在EAL中，原子式一般不具有语义，它们一般需要构成一个复合式才能被解释。
这是因为，几乎所有重要的语义的符号定义都形如：

``朋友 : 朋友[x, y] = "x和y是朋友"``

也就是说，有语义定义的符号，一般需要位于式子的头部。
在EAL中，几乎没有任何符号本身是类似于自然语言中的名词的，而更像是动词和形容词。
比起「动词」，我倾向于称它们为 **语义模板** ， ``x`` ``y`` 则是在实际表达时需要在模板上替换掉的占位符（这些占位符可形象地称为模板上的 **插槽** ）。

考虑到这个限制，实际上，上例中的 ``x`` ``y`` 也不能是原子式，为了表达「我和他是朋友」，需要如下的符号式：

``朋友[是我1[], 是他1[]]``

至于后缀标记 ``1`` 的意义何在等问题，稍后会专门解释，现在能提示你的是：上式的语义更接近于「是我的某物和是他的某物是朋友」，你可以将 ``是我`` 看作一个形容词，而 ``朋友`` 则是一个动词。

^^^^^^^^^^^^^^^^^^^^
符号式的返回值
^^^^^^^^^^^^^^^^^^^^
在EAL中，多层嵌套的符号式如

``朋友[是我1[], 是他1[]]``

之所可以被解释，不是因为外层表达式的头部 ``朋友`` 中具有如

``朋友 : 朋友[x[], y[]] = "balabala"``

这样的对多层式子的定义，而是因为内层的子式 ``是我k[]`` 为外层表达式提供了一个意为「是我的某物」的语义（这个被提供的语义约定称为 **返回值** ），然后才依照语义模板的已有定义

``朋友 : 朋友[x, y] = "x和y是朋友"``

陈述 ``是我的某物和是他的某物是朋友``。

同一语义模板可以有多种返回值，选择何种返回取决于其后的标记，这个标记可以是 ``0`` 或 ``1`` 或 ``2`` 。

* ``0``：返回值是这个式子所进行的陈述。``F0[a, b]`` 的返回值是无标记的式子 ``F[a, b]`` ，它是表示一个陈述。如 ``朋友[是我t[], 是他t[]]`` 将被解释为：「某物是我」这事与「某物是他」这事是朋友（这个语义是无法被理解，但你确实可以这么说）。
* ``1``： ``F1[a, b]`` 的返回值总是式子的首个子式 ``a`` 。例： ``朋友1[是我1[], 是他1[]]`` 的返回值是「是我的某物」。
* ``2``： ``F1[a, b]`` 的返回值总是式子的第二子式 ``b`` 。

要理解上面提到的例子，光知道标记如何确定返回值对应的表达式还不够。在解释表达式的语义时，还要用到一套称为 **子式省略** 的重要机制。

^^^^^^^^^^^^^^^^^^^^
子式省略
^^^^^^^^^^^^^^^^^^^^
在符号 ``朋友`` 的定义

``朋友 : 朋友[x, y] = "x和y是朋友"``

中，语义模板上有两个插槽 ``x`` ``y`` ，这似乎意味着一般我们必须提供两个子式给符号 ``朋友`` ，但事实并非如此。

在符号 ``是我`` 的定义

``是我 : 是我[x] = "x是我"``

中，语义模板上有且仅有一个插槽 ``x`` ，但我们在先前的例子中一直写的是 ``是我1[]`` 。可见我们不但没有提供子式给插槽 ``x`` ，甚至还用后缀标记 ``1`` 来要求返回 ``x`` 。


.. * ``0``：返回值是这个式子所进行的陈述。如 ``朋友[是我t[], 是他t[]]`` 将被解释为：「某物是我」这事与「某物是他」这事是朋友（这个语义是无法被理解，但你确实可以这么说）。
* ``1``： ``头部k[子式1, 子式2]`` 的返回值总是式子的首个子式 ``子式1`` ，但解释方法视情况而定：
	- 如果语义定义所要求的首个子式未被 **省略** ，则返回值就是第一子式。例： ``朋友k[是我t[], 是他t[]]`` 的返回值是「是我的某物」。
	- 如果语义定义所要求的首个子式被省略，则返回值是被省略的第一子式。 ``是我[x]`` 所进行的陈述是「x是我」，如果省略子式 ``x`` ，并且加上标记 ``k`` 要求返回值是这个 ``x`` ，就得到了 ``是我k[]`` 。由于只有「我」满足「x是我」，所以作为返回值的语义就是「我」。
    	- 如果能令语义模板为真的语义只有一个，那么返回值就是这个唯一的语义。
    	- 如果有多个满足要求，返回值将是一个 **变量** ，你可以对这个变量进行量化。也可以不进行量化，那么返回值将是一个抽象的 **类** 。
* ``2``：总是返回第二子式，但解释方法视情况而定：
	- 如果语义模板所要求的前两个子式都未省略或都被省略，那么返回值是令陈述为真的第二子式。例： ``朋友s[是我t[], 是他t[]]`` 的返回值是「是他的某物」。
    	- 被省略的子式的解释如 ``k`` 的情况一致。
	- 如果语义模板所要求的第二子式被省略，则返回值是第二子式。
    	- 被省略的子式的解释如 ``k`` 的情况一致。

.. 注释：上文需修改，应当分两个概念讲解：总是返回第一、二子式的k和s；返回值未输入时的返回值。

EAL不直接为事物起名字，但有摹状词，当摹状词的描摹对象被省略，我们就能利用返回值机制将对象返回来代表事物。

^^^^^^^^^^^^^^^^^^^^
选项
^^^^^^^^^^^^^^^^^^^^

--------------------
符号的语义解释
--------------------
